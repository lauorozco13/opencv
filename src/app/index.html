<html><head>
    <meta charset="utf-8">
    <title>Image Processing Video Example</title>
    <link href="js_example_style.css" rel="stylesheet" type="text/css">
    <style type="text/css">
    .dg {
        text-align: left;
    }
    .dg .property-name {
        font: 11px Lucida Grande,sans-serif;
        line-height: 27px;
    }
    .dg.main .close-button {
        font: 11px Lucida Grande,sans-serif;
        line-height: 27px;
    }
    .cell-top {
        vertical-align: top;
    }
    </style>
    <style type="text/css">.dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1!important}.dg.main .close-button.drag,.dg.main:hover .close-button{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid transparent}.dg li.title{margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.boolean,.dg .cr.boolean *,.dg .cr.function,.dg .cr.function *,.dg .cr.function .property-name{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco,monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px Lucida Grande,sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid hsla(0,0%,100%,.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.boolean:hover,.dg .cr.function:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}</style></head>
    <body>
    <h2>Image Processing Video Example</h2>
    <p>
        Open the controls and try different image processing filters.
    </p>
    <p class="err" id="errorMessage"></p>
    <div id="container">
        <table>
            <tbody><tr>
                <td></td>
                <td>
                    <div>
                        <span>Current Filter: </span><span id="filterName">Pass Through</span>
                    </div>
                </td>
                <td>
                    <div>Select Filter:</div>
                </td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td class="cell-top">
                    <canvas id="canvasOutput" width="320" height="240"></canvas>
                </td>
                <td class="cell-top">
                    <div id="guiContainer"><div class="dg main" style="width: 245px;"><ul><li class="cr function"><div><span class="property-name">Pass Through</span><div class="c"><div class="button"></div></div></div></li><li class="folder"><div class="dg"><ul class="closed"><li class="title">Color Conversion</li><li class="cr function"><div><span class="property-name">Gray</span><div class="c"><div class="button"></div></div></div></li><li class="cr function"><div><span class="property-name">HSV</span><div class="c"><div class="button"></div></div></div></li><li class="folder"><div class="dg"><ul class="closed"><li class="title">In Range</li><li class="cr number has-slider"><div><span class="property-name">lower boundary</span><div class="c"><div><input type="text"></div><div class="slider"><div class="slider-fg" style="width: 29.4118%;"></div></div></div></div></li><li class="cr number has-slider"><div><span class="property-name">higher boundary</span><div class="c"><div><input type="text"></div><div class="slider"><div class="slider-fg" style="width: 58.8235%;"></div></div></div></div></li></ul></div></li></ul></div></li><li class="folder"><div class="dg"><ul class="closed"><li class="title">Thresholding</li><li class="folder"><div class="dg"><ul class="closed"><li class="title">Threshold</li><li class="cr number has-slider"><div><span class="property-name">threshold value</span><div class="c"><div><input type="text"></div><div class="slider"><div class="slider-fg" style="width: 50%;"></div></div></div></div></li></ul></div></li><li class="folder"><div class="dg"><ul class="closed"><li class="title">Adaptive Threshold</li><li class="cr number has-slider"><div><span class="property-name">block size</span><div class="c"><div><input type="text"></div><div class="slider"><div class="slider-fg" style="width: 0%;"></div></div></div></div></li></ul></div></li></ul></div></li><li class="folder"><div class="dg"><ul class="closed"><li class="title">Smoothing</li><li class="folder"><div class="dg"><ul class="closed"><li class="title">Gaussian Blurring</li><li class="cr number has-slider"><div><span class="property-name">kernel size</span><div class="c"><div><input type="text"></div><div class="slider"><div class="slider-fg" style="width: 0%;"></div></div></div></div></li></ul></div></li><li class="folder"><div class="dg"><ul class="closed"><li class="title">Median Blurring</li><li class="cr number has-slider"><div><span class="property-name">kernel size</span><div class="c"><div><input type="text"></div><div class="slider"><div class="slider-fg" style="width: 2.08333%;"></div></div></div></div></li></ul></div></li><li class="folder"><div class="dg"><ul class="closed"><li class="title">Bilateral Filtering</li><li class="cr number has-slider"><div><span class="property-name">diameter</span><div class="c"><div><input type="text"></div><div class="slider"><div class="slider-fg" style="width: 28.5714%;"></div></div></div></div></li><li class="cr number has-slider"><div><span class="property-name">sigma</span><div class="c"><div><input type="text"></div><div class="slider"><div class="slider-fg" style="width: 29.1339%;"></div></div></div></div></li></ul></div></li></ul></div></li><li class="folder"><div class="dg"><ul class="closed"><li class="title">Morphology</li><li class="cr number"><div><span class="property-name">operation</span><div class="c"><select><option value="0">MORPH_ERODE</option><option value="1">MORPH_DILATE</option><option value="2">MORPH_OPEN </option><option value="3">MORPH_CLOSE</option><option value="4">MORPH_GRADIENT</option><option value="5">MORPH_TOPHAT</option><option value="6">MORPH_BLACKHAT</option></select></div></div></li><li class="cr number"><div><span class="property-name">shape</span><div class="c"><select><option value="0">MORPH_RECT</option><option value="1">MORPH_CROSS</option><option value="2">MORPH_ELLIPSE</option></select></div></div></li><li class="cr number has-slider"><div><span class="property-name">kernel size</span><div class="c"><div><input type="text"></div><div class="slider"><div class="slider-fg" style="width: 28.5714%;"></div></div></div></div></li><li class="cr number"><div><span class="property-name">boarder type</span><div class="c"><select><option value="0">BORDER_CONSTANT</option><option value="1">BORDER_REPLICATE</option><option value="2">BORDER_REFLECT</option><option value="4">BORDER_REFLECT_101</option></select></div></div></li></ul></div></li><li class="folder"><div class="dg"><ul class="closed"><li class="title">Gradients</li><li class="folder"><div class="dg"><ul class="closed"><li class="title">Sobel Derivatives</li><li class="cr number has-slider"><div><span class="property-name">kernel size</span><div class="c"><div><input type="text"></div><div class="slider"><div class="slider-fg" style="width: 0%;"></div></div></div></div></li></ul></div></li><li class="cr function"><div><span class="property-name">Scharr Derivatives</span><div class="c"><div class="button"></div></div></div></li><li class="folder"><div class="dg"><ul class="closed"><li class="title">Laplacian Derivatives</li><li class="cr number has-slider"><div><span class="property-name">kernel size</span><div class="c"><div><input type="text"></div><div class="slider"><div class="slider-fg" style="width: 11.1111%;"></div></div></div></div></li></ul></div></li></ul></div></li><li class="folder"><div class="dg"><ul class="closed"><li class="title">Canny Edge Detection</li><li class="cr number has-slider"><div><span class="property-name">threshold1</span><div class="c"><div><input type="text"></div><div class="slider"><div class="slider-fg" style="width: 29.8597%;"></div></div></div></div></li><li class="cr number has-slider"><div><span class="property-name">threshold2</span><div class="c"><div><input type="text"></div><div class="slider"><div class="slider-fg" style="width: 59.9198%;"></div></div></div></div></li><li class="cr number has-slider"><div><span class="property-name">aperture size</span><div class="c"><div><input type="text"></div><div class="slider"><div class="slider-fg" style="width: 0%;"></div></div></div></div></li><li class="cr boolean"><div><span class="property-name">l2 gradient</span><div class="c"><input type="checkbox"></div></div></li></ul></div></li><li class="folder"><div class="dg"><ul class="closed"><li class="title">Contours</li><li class="cr number"><div><span class="property-name">mode</span><div class="c"><select><option value="0">RETR_EXTERNAL</option><option value="1">RETR_LIST</option><option value="2">RETR_CCOMP</option><option value="3">RETR_TREE</option></select></div></div></li><li class="cr number"><div><span class="property-name">method</span><div class="c"><select><option value="1">CHAIN_APPROX_NONE</option><option value="2">CHAIN_APPROX_SIMPLE</option><option value="3">CHAIN_APPROX_TC89_L1</option><option value="4">CHAIN_APPROX_TC89_KCOS</option></select></div></div></li></ul></div></li><li class="folder"><div class="dg"><ul class="closed"><li class="title">Histograms</li><li class="cr function"><div><span class="property-name">Calculation</span><div class="c"><div class="button"></div></div></div></li><li class="cr function"><div><span class="property-name">Equalization</span><div class="c"><div class="button"></div></div></div></li><li class="folder"><div class="dg"><ul class="closed"><li class="title">Backprojection</li><li class="cr number has-slider"><div><span class="property-name">range low</span><div class="c"><div><input type="text"></div><div class="slider"><div class="slider-fg" style="width: 0%;"></div></div></div></div></li><li class="cr number has-slider"><div><span class="property-name">range high</span><div class="c"><div><input type="text"></div><div class="slider"><div class="slider-fg" style="width: 58.8235%;"></div></div></div></div></li></ul></div></li></ul></div></li></ul><div class="close-button close-bottom" style="width: 245px;">Close Controls</div></div></div>
                </td>
                <td></td>
            </tr>
        </tbody></table>
        <div>
            <video id="videoInput" class="hidden" width="320" height="240">Your browser does not support the video tag.</video>
        </div>
    <div style="cursor: pointer; opacity: 0.9; position: absolute; right: 0px; top: 0px;"><canvas width="80" height="48" style="width: 80px; height: 48px; display: block;"></canvas><canvas width="80" height="48" style="width: 80px; height: 48px; display: none;"></canvas><canvas width="80" height="48" style="width: 80px; height: 48px; display: none;"></canvas></div></div>
    <script async="" type="text/javascript" src="opencv.js"></script><script src="https://webrtc.github.io/adapter/adapter-5.0.4.js" type="text/javascript"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js" type="text/javascript"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.4/dat.gui.min.js" type="text/javascript"></script>
    <script src="utils.js" type="text/javascript"></script>
    <script type="text/javascript">
    let utils = new Utils('errorMessage');
    
    let width = 0;
    let height = 0;
    
    let resolution = window.innerWidth < 960 ? 'qvga' : 'vga';
    
    // whether streaming video from the camera.
    let streaming = false;
    
    let video = document.getElementById('videoInput');
    let vc = null;
    
    let container = document.getElementById('container');
    
    let lastFilter = '';
    let src = null;
    let dstC1 = null;
    let dstC3 = null;
    let dstC4 = null;
    
    function startVideoProcessing() {
        src = new cv.Mat(height, width, cv.CV_8UC4);
        dstC1 = new cv.Mat(height, width, cv.CV_8UC1);
        dstC3 = new cv.Mat(height, width, cv.CV_8UC3);
        dstC4 = new cv.Mat(height, width, cv.CV_8UC4);
        requestAnimationFrame(processVideo);
    }
    
    function passThrough(src) {
        return src;
    }
    
    function gray(src) {
        cv.cvtColor(src, dstC1, cv.COLOR_RGBA2GRAY);
        return dstC1;
    }
    
    function hsv(src) {
        cv.cvtColor(src, dstC3, cv.COLOR_RGBA2RGB);
        cv.cvtColor(dstC3, dstC3, cv.COLOR_RGB2HSV);
        return dstC3;
    }
    
    function canny(src) {
        cv.cvtColor(src, dstC1, cv.COLOR_RGBA2GRAY);
        cv.Canny(dstC1, dstC1, controls.cannyThreshold1, controls.cannyThreshold2,
                 controls.cannyApertureSize, controls.cannyL2Gradient);
        return dstC1;
    }
    
    function inRange(src) {
        let lowValue = controls.inRangeLow;
        let lowScalar = new cv.Scalar(lowValue, lowValue, lowValue, 255);
        let highValue = controls.inRangeHigh;
        let highScalar = new cv.Scalar(highValue, highValue, highValue, 255);
        let low = new cv.Mat(height, width, src.type(), lowScalar);
        let high = new cv.Mat(height, width, src.type(), highScalar);
        cv.inRange(src, low, high, dstC1);
        low.delete(); high.delete();
        return dstC1;
    }
    
    function threshold(src) {
        cv.threshold(src, dstC4, controls.thresholdValue, 200, cv.THRESH_BINARY);
        return dstC4;
    }
    
    function adaptiveThreshold(src) {
        let mat = new cv.Mat(height, width, cv.CV_8U);
        cv.cvtColor(src, mat, cv.COLOR_RGBA2GRAY);
        cv.adaptiveThreshold(mat, dstC1, 200, cv.ADAPTIVE_THRESH_GAUSSIAN_C,
                             cv.THRESH_BINARY, Number(controls.adaptiveBlockSize), 2);
        mat.delete();
        return dstC1;
    }
    
    function gaussianBlur(src) {
        cv.GaussianBlur(src, dstC4,
                        {width: controls.gaussianBlurSize, height: controls.gaussianBlurSize},
                        0, 0, cv.BORDER_DEFAULT);
        return dstC4;
    }
    
    function bilateralFilter(src) {
        let mat = new cv.Mat(height, width, cv.CV_8UC3);
        cv.cvtColor(src, mat, cv.COLOR_RGBA2RGB);
        cv.bilateralFilter(mat, dstC3, controls.bilateralFilterDiameter, controls.bilateralFilterSigma,
                           controls.bilateralFilterSigma, cv.BORDER_DEFAULT);
        mat.delete();
        return dstC3;
    }
    
    function medianBlur(src) {
        cv.medianBlur(src, dstC4, controls.medianBlurSize);
        return dstC4;
    }
    
    function sobel(src) {
        let mat = new cv.Mat(height, width, cv.CV_8UC1);
        cv.cvtColor(src, mat, cv.COLOR_RGB2GRAY, 0);
        cv.Sobel(mat, dstC1, cv.CV_8U, 1, 0, controls.sobelSize, 1, 0, cv.BORDER_DEFAULT);
        mat.delete();
        return dstC1;
    }
    
    function scharr(src) {
        let mat = new cv.Mat(height, width, cv.CV_8UC1);
        cv.cvtColor(src, mat, cv.COLOR_RGB2GRAY, 0);
        cv.Scharr(mat, dstC1, cv.CV_8U, 1, 0, 1, 0, cv.BORDER_DEFAULT);
        mat.delete();
        return dstC1;
    }
    
    function laplacian(src) {
        let mat = new cv.Mat(height, width, cv.CV_8UC1);
        cv.cvtColor(src, mat, cv.COLOR_RGB2GRAY);
        cv.Laplacian(mat, dstC1, cv.CV_8U, controls.laplacianSize, 1, 0, cv.BORDER_DEFAULT);
        mat.delete();
        return dstC1;
    }
    
    let contoursColor = [];
    for (let i = 0; i < 10000; i++) {
        contoursColor.push([Math.round(Math.random() * 255),
                            Math.round(Math.random() * 255),
                            Math.round(Math.random() * 255), 0]);
    }
    
    function contours(src) {
        cv.cvtColor(src, dstC1, cv.COLOR_RGBA2GRAY);
        cv.threshold(dstC1, dstC4, 120, 200, cv.THRESH_BINARY);
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(dstC4, contours, hierarchy,
                        Number(controls.contoursMode),
                        Number(controls.contoursMethod), {x: 0, y: 0});
        dstC3.delete();
        dstC3 = cv.Mat.ones(height, width, cv.CV_8UC3);
        for (let i = 0; i<contours.size(); ++i) {
            let color = contoursColor[i];
            cv.drawContours(dstC3, contours, i, color, 1, cv.LINE_8, hierarchy);
        }
        contours.delete(); hierarchy.delete();
        return dstC3;
    }
    
    function calcHist(src) {
        cv.cvtColor(src, dstC1, cv.COLOR_RGBA2GRAY);
        let srcVec = new cv.MatVector();
        srcVec.push_back(dstC1);
        let scale = 2;
        let channels = [0];
        let histSize = [src.cols/scale];
        const ranges = [0, 255];
        let hist = new cv.Mat();
        let mask = new cv.Mat();
        let color = new cv.Scalar(0xfb, 0xca, 0x04, 0xff);
        cv.calcHist(srcVec, channels, mask, hist, histSize, ranges);
        let result = cv.minMaxLoc(hist, mask);
        let max = result.maxVal;
        cv.cvtColor(dstC1, dstC4, cv.COLOR_GRAY2RGBA);
        // draw histogram on src
        for (let i = 0; i < histSize[0]; i++) {
            let binVal = hist.data32F[i] * src.rows / max;
            cv.rectangle(dstC4, {x: i * scale, y: src.rows - 1},
                         {x: (i + 1) * scale - 1, y: src.rows - binVal/3}, color, cv.FILLED);
        }
        srcVec.delete();
        mask.delete();
        hist.delete();
        return dstC4;
    }
    
    function equalizeHist(src) {
        cv.cvtColor(src, dstC1, cv.COLOR_RGBA2GRAY, 0);
        cv.equalizeHist(dstC1, dstC1);
        return dstC1;
    }
    
    let base;
    
    function backprojection(src) {
        if (lastFilter !== 'backprojection') {
            if (base instanceof cv.Mat) {
                base.delete();
            }
            base = src.clone();
            cv.cvtColor(base, base, cv.COLOR_RGB2HSV, 0);
        }
        cv.cvtColor(src, dstC3, cv.COLOR_RGB2HSV, 0);
        let baseVec = new cv.MatVector();
        let targetVec = new cv.MatVector();
        baseVec.push_back(base); targetVec.push_back(dstC3);
        let mask = new cv.Mat();
        let hist = new cv.Mat();
        let channels = [0];
        let histSize = [50];
        let ranges;
        if (controls.backprojectionRangeLow < controls.backprojectionRangeHigh) {
            ranges = [controls.backprojectionRangeLow, controls.backprojectionRangeHigh];
        } else {
            return src;
        }
        cv.calcHist(baseVec, channels, mask, hist, histSize, ranges);
        cv.normalize(hist, hist, 0, 255, cv.NORM_MINMAX);
        cv.calcBackProject(targetVec, channels, hist, dstC1, ranges, 1);
        baseVec.delete();
        targetVec.delete();
        mask.delete();
        hist.delete();
        return dstC1;
    }
    
    function erosion(src) {
        let kernelSize = controls.erosionSize;
        let kernel = cv.Mat.ones(kernelSize, kernelSize, cv.CV_8U);
        let color = new cv.Scalar();
        cv.erode(src, dstC4, kernel, {x: -1, y: -1}, 1, Number(controls.erosionBorderType), color);
        kernel.delete();
        return dstC4;
    }
    
    function dilation(src) {
        let kernelSize = controls.dilationSize;
        let kernel = cv.Mat.ones(kernelSize, kernelSize, cv.CV_8U);
        let color = new cv.Scalar();
        cv.dilate(src, dstC4, kernel, {x: -1, y: -1}, 1, Number(controls.dilationBorderType), color);
        kernel.delete();
        return dstC4;
    }
    
    function morphology(src) {
        let kernelSize = controls.morphologySize;
        let kernel = cv.getStructuringElement(Number(controls.morphologyShape),
                                              {width: kernelSize, height: kernelSize});
        let color = new cv.Scalar();
        let op = Number(controls.morphologyOp);
        let image = src;
        if (op === cv.MORPH_GRADIENT || op === cv.MORPH_TOPHAT || op === cv.MORPH_BLACKHAT) {
            cv.cvtColor(src, dstC3, cv.COLOR_RGBA2RGB);
            image = dstC3;
        }
        cv.morphologyEx(image, dstC4, op, kernel, {x: -1, y: -1}, 1,
                        Number(controls.morphologyBorderType), color);
        kernel.delete();
        return dstC4;
    }
    
    function processVideo() {
        if (!streaming) return;
        stats.begin();
        vc.read(src);
        let result;
        switch (controls.filter) {
            case 'passThrough': result = passThrough(src); break;
            case 'gray': result = gray(src); break;
            case 'hsv': result = hsv(src); break;
            case 'canny': result = canny(src); break;
            case 'inRange': result = inRange(src); break;
            case 'threshold': result = threshold(src); break;
            case 'adaptiveThreshold': result = adaptiveThreshold(src); break;
            case 'gaussianBlur': result = gaussianBlur(src); break;
            case 'bilateralFilter': result = bilateralFilter(src); break;
            case 'medianBlur': result = medianBlur(src); break;
            case 'sobel': result = sobel(src); break;
            case 'scharr': result = scharr(src); break;
            case 'laplacian': result = laplacian(src); break;
            case 'contours': result = contours(src); break;
            case 'calcHist': result = calcHist(src); break;
            case 'equalizeHist': result = equalizeHist(src); break;
            case 'backprojection': result = backprojection(src); break;
            case 'erosion': result = erosion(src); break;
            case 'dilation': result = dilation(src); break;
            case 'morphology': result = morphology(src); break;
            default: result = passThrough(src);
        }
        cv.imshow('canvasOutput', result);
        stats.end();
        lastFilter = controls.filter;
        requestAnimationFrame(processVideo);
    }
    
    let stats = null;
    
    let filters = {
        'passThrough': 'Pass Through',
        'gray': 'Gray',
        'hsv': 'HSV',
        'canny': 'Canny Edge Detection',
        'inRange': 'In Range',
        'threshold': 'Threshold',
        'adaptiveThreshold': 'Adaptive Threshold',
        'gaussianBlur': 'Gaussian Blurring',
        'medianBlur': 'Median Blurring',
        'bilateralFilter': 'Bilateral Filtering',
        'sobel': 'Sobel Derivatives',
        'scharr': 'Scharr Derivatives',
        'laplacian': 'Laplacian Derivatives',
        'contours': 'Contours',
        'calcHist': 'Calculation',
        'equalizeHist': 'Equalization',
        'backprojection': 'Backprojection',
        'erosion': 'Erosion',
        'dilation': 'Dilation',
        'morphology': 'Morphology',
    };
    
    let filterName = document.getElementById('filterName');
    
    let controls;
    
    function initUI() {
        stats = new Stats();
        stats.showPanel(0);
        container.appendChild(stats.domElement);
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.right = '0px';
        stats.domElement.style.top = '0px';
    
        controls = {
            filter: 'passThrough',
            setFilter: function(filter) {
                this.filter = filter;
                filterName.innerHTML = filters[filter];
            },
            passThrough: function() {
                this.setFilter('passThrough');
            },
            gray: function() {
                this.setFilter('gray');
            },
            hsv: function() {
                this.setFilter('hsv');
            },
            inRange: function() {
                this.setFilter('inRange');
            },
            inRangeLow: 75,
            inRangeHigh: 150,
            threshold: function() {
                this.setFilter('threshold');
            },
            thresholdValue: 100,
            adaptiveThreshold: function() {
                this.setFilter('adaptiveThreshold');
            },
            adaptiveBlockSize: 3,
            gaussianBlur: function() {
                this.setFilter('gaussianBlur');
            },
            gaussianBlurSize: 7,
            medianBlur: function() {
                this.setFilter('medianBlur');
            },
            medianBlurSize: 5,
            bilateralFilter: function() {
                this.setFilter('bilateralFilter');
            },
            bilateralFilterDiameter: 5,
            bilateralFilterSigma: 75,
            sobel: function() {
                this.setFilter('sobel');
            },
            sobelSize: 3,
            scharr: function() {
                this.setFilter('scharr');
            },
            laplacian: function() {
                this.setFilter('laplacian');
            },
            laplacianSize: 3,
            canny: function() {
                this.setFilter('canny');
            },
            cannyThreshold1: 150,
            cannyThreshold2: 300,
            cannyApertureSize: 3,
            cannyL2Gradient: false,
            contours: function() {
                this.setFilter('contours');
            },
            contoursMode: cv.RETR_CCOMP,
            contoursMethod: cv.CHAIN_APPROX_SIMPLE,
            calcHist: function() {
                this.setFilter('calcHist');
            },
            equalizeHist: function() {
                this.setFilter('equalizeHist');
            },
            backprojection: function() {
                this.setFilter('backprojection');
            },
            backprojectionRangeLow: 0,
            backprojectionRangeHigh: 150,
            morphology: function() {
                this.setFilter('morphology');
            },
            morphologyShape: cv.MORPH_RECT,
            morphologyOp: cv.MORPH_ERODE,
            morphologySize: 5,
            morphologyBorderType: cv.BORDER_CONSTANT,
        };
    
        let gui = new dat.GUI({autoPlace: false});
        let guiContainer = document.getElementById('guiContainer');
        guiContainer.appendChild(gui.domElement);
    
        let lastFolder = null;
        function closeLastFolder(folder) {
            if (lastFolder != null && lastFolder != folder) {
                lastFolder.close();
            }
            lastFolder = folder;
        }
    
        gui.add(controls, 'passThrough').name(filters['passThrough']).onChange(function() {
            closeLastFolder(null);
        });
    
        let colorConversion = gui.addFolder('Color Conversion');
        colorConversion.add(controls, 'gray').name(filters['gray']).onChange(function() {
            closeLastFolder(null);
        });
    
        colorConversion.add(controls, 'hsv').name(filters['hsv']).onChange(function() {
            closeLastFolder(null);
        });
    
        let inRange = colorConversion.addFolder(filters['inRange']);
        inRange.domElement.onclick = function() {
            closeLastFolder(inRange);
            controls.inRange();
        };
        inRange.add(controls, 'inRangeLow', 0, 255, 1).name('lower boundary');
        inRange.add(controls, 'inRangeHigh', 0, 255, 1).name('higher boundary');
    
        // let geometricTransformations = gui.addFolder('Geometric Transformations');
        // TODO
    
        let thresholding = gui.addFolder('Thresholding');
    
        let threshold = thresholding.addFolder(filters['threshold']);
        threshold.domElement.onclick = function() {
            closeLastFolder(threshold);
            controls.threshold();
        };
        threshold.add(controls, 'thresholdValue', 0, 200, 1).name('threshold value');
    
        let adaptiveThreshold = thresholding.addFolder(filters['adaptiveThreshold']);
        adaptiveThreshold.domElement.onclick = function() {
            closeLastFolder(adaptiveThreshold);
            controls.adaptiveThreshold();
        };
        adaptiveThreshold.add(
            controls, 'adaptiveBlockSize', 3, 99, 1).name('block size').onChange(
            function(value) {
                if (value % 2 === 0) controls.adaptiveBlockSize = value + 1;
            });
    
        let smoothing = gui.addFolder('Smoothing');
    
        let gaussianBlur = smoothing.addFolder(filters['gaussianBlur']);
        gaussianBlur.domElement.onclick = function() {
            closeLastFolder(gaussianBlur);
            controls.gaussianBlur();
        };
        gaussianBlur.add(
            controls, 'gaussianBlurSize', 7, 99, 1).name('kernel size').onChange(
            function(value) {
                if (value % 2 === 0) controls.gaussianBlurSize = value + 1;
            });
    
        let medianBlur = smoothing.addFolder(filters['medianBlur']);
        medianBlur.domElement.onclick = function() {
            closeLastFolder(medianBlur);
            controls.medianBlur();
        };
        medianBlur.add(
            controls, 'medianBlurSize', 3, 99, 1).name('kernel size').onChange(
            function(value) {
                if (value % 2 === 0) controls.medianBlurSize = value + 1;
            });
    
        let bilateralFilter = smoothing.addFolder(filters['bilateralFilter']);
        bilateralFilter.domElement.onclick = function() {
            closeLastFolder(bilateralFilter);
            controls.bilateralFilter();
        };
        bilateralFilter.add(controls, 'bilateralFilterDiameter', 1, 15, 1).name('diameter');
        bilateralFilter.add(controls, 'bilateralFilterSigma', 1, 255, 1).name('sigma');
    
        let morphology = gui.addFolder('Morphology');
        morphology.domElement.onclick = function() {
            closeLastFolder(morphology);
            controls.morphology();
        };
        morphology.add(
            controls, 'morphologyOp',
            {'MORPH_ERODE': cv.MORPH_ERODE,
             'MORPH_DILATE': cv.MORPH_DILATE,
             'MORPH_OPEN ': cv.MORPH_OPEN,
             'MORPH_CLOSE': cv.MORPH_CLOSE,
             'MORPH_GRADIENT': cv.MORPH_GRADIENT,
             'MORPH_TOPHAT': cv.MORPH_TOPHAT,
             'MORPH_BLACKHAT': cv.MORPH_BLACKHAT}).name('operation');
        morphology.add(
            controls, 'morphologyShape',
            {'MORPH_RECT': cv.MORPH_RECT,
             'MORPH_CROSS': cv.MORPH_CROSS,
             'MORPH_ELLIPSE': cv.MORPH_ELLIPSE}).name('shape');
        morphology.add(
            controls, 'morphologySize', 1, 15, 1).name('kernel size').onChange(
            function(value) {
                if (value % 2 === 0) controls.morphologySize = value + 1;
            });
        morphology.add(
            controls, 'morphologyBorderType',
            {'BORDER_CONSTANT': cv.BORDER_CONSTANT,
             'BORDER_REPLICATE': cv.BORDER_REPLICATE,
             'BORDER_REFLECT': cv.BORDER_REFLECT,
             'BORDER_REFLECT_101': cv.BORDER_REFLECT_101}).name('boarder type');
    
        let gradients = gui.addFolder('Gradients');
        let sobel = gradients.addFolder(filters['sobel']);
        sobel.domElement.onclick = function() {
            closeLastFolder(sobel);
            controls.sobel();
        };
        sobel.add(controls, 'sobelSize', 3, 19, 1).name('kernel size').onChange(function(value) {
            if (value % 2 === 0) controls.sobelSize = value + 1;
        });
    
        gradients.add(controls, 'scharr').name(filters['scharr']).onChange(function() {
            closeLastFolder(null);
        });
    
        let laplacian = gradients.addFolder(filters['laplacian']);
        laplacian.domElement.onclick = function() {
            closeLastFolder(laplacian);
            controls.laplacian();
        };
        laplacian.add(
            controls, 'laplacianSize', 1, 19, 1).name('kernel size').onChange(
            function(value) {
                if (value % 2 === 0) controls.laplacianSize = value + 1;
            });
    
        let canny = gui.addFolder(filters['canny']);
        canny.domElement.onclick = function() {
            closeLastFolder(canny);
            controls.canny();
        };
        canny.add(controls, 'cannyThreshold1', 1, 500, 1).name('threshold1');
        canny.add(controls, 'cannyThreshold2', 1, 500, 1).name('threshold2');
        canny.add(controls, 'cannyApertureSize', 3, 7, 1).name('aperture size').onChange(
            function(value) {
                if (value % 2 === 0) controls.cannyApertureSize = value + 1;
            });
        canny.add(controls, 'cannyL2Gradient').name('l2 gradient');
    
        let contours = gui.addFolder(filters['contours']);
        contours.domElement.onclick = function() {
            closeLastFolder(contours);
            controls.contours();
        };
        contours.add(
            controls, 'contoursMode',
            {'RETR_EXTERNAL': cv.RETR_EXTERNAL,
             'RETR_LIST': cv.RETR_LIST,
             'RETR_CCOMP': cv.RETR_CCOMP,
             'RETR_TREE': cv.RETR_TREE}).name('mode');
        contours.add(
            controls, 'contoursMethod',
            {'CHAIN_APPROX_NONE': cv.CHAIN_APPROX_NONE,
             'CHAIN_APPROX_SIMPLE': cv.CHAIN_APPROX_SIMPLE,
             'CHAIN_APPROX_TC89_L1': cv.CHAIN_APPROX_TC89_L1,
             'CHAIN_APPROX_TC89_KCOS': cv.CHAIN_APPROX_TC89_KCOS}).name('method');
    
        let histograms = gui.addFolder('Histograms');
        histograms.add(controls, 'calcHist').name(filters['calcHist']).onChange(function() {
            closeLastFolder(null);
        });
        histograms.add(controls, 'equalizeHist').name(filters['equalizeHist']).onChange(function() {
            closeLastFolder(null);
        });
    
        let backprojection = histograms.addFolder(filters['backprojection']);
        backprojection.domElement.onclick = function() {
            closeLastFolder(backprojection);
            controls.backprojection();
        };
        backprojection.add(controls, 'backprojectionRangeLow', 0, 255, 1).name('range low');
        backprojection.add(controls, 'backprojectionRangeHigh', 0, 255, 1).name('range high');
    }
    
    function startCamera() {
        if (!streaming) {
            utils.clearError();
            utils.startCamera(resolution, onVideoStarted, 'videoInput');
        } else {
            utils.stopCamera();
            onVideoStopped();
        }
    }
    
    function onVideoStarted() {
        height = video.videoHeight;
        width = video.videoWidth;
        video.setAttribute('width', width);
        video.setAttribute('height', height);
        streaming = true;
        vc = new cv.VideoCapture(video);
        startVideoProcessing();
    }
    
    function stopVideoProcessing() {
        if (src != null && !src.isDeleted()) src.delete();
        if (dstC1 != null && !dstC1.isDeleted()) dstC1.delete();
        if (dstC3 != null && !dstC3.isDeleted()) dstC3.delete();
        if (dstC4 != null && !dstC4.isDeleted()) dstC4.delete();
    }
    
    function onVideoStopped() {
        if (!streaming) return;
        stopVideoProcessing();
        document.getElementById('canvasOutput').getContext('2d').clearRect(0, 0, width, height);
        streaming = false;
    }
    
    utils.loadOpenCv(() => {
        initUI();
        startCamera();
    });
    </script>
    
    
    </body></html>